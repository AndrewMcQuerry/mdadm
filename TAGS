
Assemble.c,22
int Assemble(34,1176

Build.c,100
#define REGISTER_DEV 32,1140
#define START_MD 33,1181
#define STOP_MD 34,1222
int Build(36,1264

COPYING,99
program will will52,2561
program proprietary.proprietary53,2632
PROGRAM PROVE PROVE267,14397

ChangeLog,294
    -   When --assemble --force,13,443
    -   When marking drives as not-failed in the superblock,16,627
	are passed as unsigned lock,23,1044
    -   If HOT_ADD_DISK failes for -a,24,1100
	if we cannot read from the array,25,1166
	and mdctl.conf compatible description with uuid=31,1443

Create.c,20
int Create(34,1176

Detail.c,20
int Detail(34,1176

Examine.c,21
int Examine(38,1285

Kill.c,18
int Kill(37,1237

Makefile,12
CC 30,1091

Manage.c,161
#define REGISTER_DEV 34,1176
#define START_MD 35,1217
#define STOP_MD 36,1258
int Manage_ro(38,1300
int Manage_runstop(75,2154
int Manage_subdevs(118,3161

Monitor.c,49
int Monitor(37,1283
static void alert(175,4727

ReadMe.c,266
char Version[32,1140
char short_options[81,3226
struct option long_options[82,3290
char Usage[140,4885
char Help[145,4942
char Help_create[218,8393
char Help_build[245,9615
char Help_assemble[258,10155
mapping_t r5layout[317,13101
mapping_t pers[331,13317

TODO,590
* write proc.c to parse /proc/mdstat file,5,65
   Build list of arrays:  name,6,140
* --detail --scan to read mdctl.conf,8,189
* --detail --scan to read mdctl.conf, and then iterate over these,8,189
- set md_minor,34,933
- for create raid5,35,976
   all working,36,1019
   one missing,37,1050
   one missing, one spare,37,1050
- when RUN_ARRAY,40,1152
- get --detail to extract extra stuff from superblock,42,1206
- when --assemble --scan,48,1368
- when --assemble --scan, if an underlying device is an md device,48,1368
ARRAY lines in config file to have super_minor=62,1797

config.c,479
char DefaultConfFile[68,2401
char *keywords[70,2446
int match_keyword(77,2645
char *conf_word(97,3153
char *conf_line(163,4744
void free_line(184,5046
struct conf_dev conf_dev195,5188
} *cdevlist 198,5249
int devline(202,5272
mddev_ident_t mddevlist 220,5595
mddev_ident_t *mddevlp 221,5627
void arrayline(223,5665
int loaded 303,7978
void load_conffile(305,7995
mddev_ident_t conf_get_ident(338,8486
mddev_dev_t conf_get_devs(348,8688
int match_oneof(383,9316

dlink.c,177
void *dl_head(11,180
void dl_free(20,289
void dl_init(26,363
void dl_insert(32,430
void dl_add(40,598
void dl_del(48,763
char *dl_strndup(57,969
char *dl_strdup(73,1176

dlink.h,193
struct __dl_head__dl_head5,100
#define	dl_alloc(dl_alloc11,187
#define	dl_new(dl_new12,297
#define	dl_newv(dl_newv13,341
#define dl_next(dl_next15,391
#define dl_prev(dl_prev16,461

makedist,127
target=3,11
( cd .. ; ln -s mdctl mdctl-$version 19,352
( cd .. ; ln -s mdctl mdctl-$version ; tar czhvf - --exclude=19,352

md_p.h,1316
#define _MD_P_H16,582
#define MD_RESERVED_BYTES	44,1414
#define MD_RESERVED_SECTORS	45,1453
#define MD_RESERVED_BLOCKS	46,1508
#define MD_NEW_SIZE_SECTORS(MD_NEW_SIZE_SECTORS48,1570
#define MD_NEW_SIZE_BLOCKS(MD_NEW_SIZE_BLOCKS49,1659
#define MD_SB_BYTES	51,1746
#define MD_SB_WORDS	52,1773
#define MD_SB_BLOCKS	53,1813
#define MD_SB_SECTORS	54,1863
#define	MD_SB_GENERIC_OFFSET	59,1960
#define MD_SB_PERSONALITY_OFFSET	60,1992
#define MD_SB_DISKS_OFFSET	61,2028
#define MD_SB_DESCRIPTOR_OFFSET	62,2060
#define MD_SB_GENERIC_CONSTANT_WORDS	64,2098
#define MD_SB_GENERIC_STATE_WORDS	65,2138
#define MD_SB_GENERIC_WORDS	66,2175
#define MD_SB_PERSONALITY_WORDS	67,2263
#define MD_SB_DESCRIPTOR_WORDS	68,2299
#define MD_SB_DISKS	69,2334
#define MD_SB_DISKS_WORDS	70,2359
#define MD_SB_RESERVED_WORDS	71,2423
#define MD_SB_EQUAL_WORDS	72,2553
#define MD_DISK_FAULTY	77,2691
#define MD_DISK_ACTIVE	78,2752
#define MD_DISK_SYNC	79,2814
#define MD_DISK_REMOVED	80,2878
typedef struct mdp_device_descriptor_s mdp_device_descriptor_s82,2946
} mdp_disk_t;mdp_disk_t89,3310
#define MD_SB_MAGIC	91,3325
#define MD_SB_CLEAN	96,3390
#define MD_SB_ERRORS	97,3413
typedef struct mdp_superblock_s mdp_superblock_s99,3438
} mdp_super_t;mdp_super_t164,5835
static inline __u64 md_event(166,5851

md_u.h,1118
#define _MD_U_H16,590
#define RAID_VERSION	21,634
#define GET_ARRAY_INFO	22,693
#define GET_DISK_INFO	23,757
#define PRINT_RAID_DEBUG	24,819
#define RAID_AUTORUN	25,865
#define CLEAR_ARRAY	28,929
#define ADD_NEW_DISK	29,971
#define HOT_REMOVE_DISK	30,1032
#define SET_ARRAY_INFO	31,1078
#define SET_DISK_INFO	32,1142
#define WRITE_RAID_INFO	33,1186
#define UNPROTECT_ARRAY	34,1232
#define PROTECT_ARRAY	35,1278
#define HOT_ADD_DISK	36,1322
#define SET_DISK_FAULTY	37,1365
#define RUN_ARRAY	40,1424
#define START_ARRAY	41,1478
#define STOP_ARRAY	42,1520
#define STOP_ARRAY_RO	43,1561
#define RESTART_ARRAY_RW	44,1605
typedef struct mdu_version_s mdu_version_s46,1652
} mdu_version_t;mdu_version_t50,1724
typedef struct mdu_array_info_s mdu_array_info_s52,1742
} mdu_array_info_t;mdu_array_info_t83,2516
typedef struct mdu_disk_info_s mdu_disk_info_s85,2537
} mdu_disk_info_t;mdu_disk_info_t95,2693
typedef struct mdu_start_info_s mdu_start_info_s97,2713
} mdu_start_info_t;mdu_start_info_t106,2857
typedef struct mdu_param_smdu_param_s108,2878
} mdu_param_t;mdu_param_t113,3014

mdctl.8,252
real block devices. This allows multiple devices 14,241
{left,right}-{,a}symmetric,185,4006
{left,right}-{,a}symmetric, la,185,4006
{left,right}-{,a}symmetric, la, ra,185,4006
{left,right}-{,a}symmetric, la, ra, ls,185,4006
.BR --layout=188,4087

mdctl.c,64
int open_mddev(33,1158
int main(50,1477
#define O(O177,4288

mdctl.h,855
#define	__USE_LARGEFILE6430,1120
#define	MD_MAJOR 47,1496
#define Name 52,1536
extern char short_options[54,1558
extern struct option long_options[55,1587
extern char Version[56,1624
extern char Version[], Usage[56,1624
extern char Version[], Usage[], Help[56,1624
extern char Version[], Usage[], Help[], Help_create[56,1624
extern char Version[], Usage[], Help[], Help_create[], Help_build[56,1624
extern char Version[], Usage[], Help[], Help_create[], Help_build[], Help_assemble[56,1624
typedef struct mddev_ident_s mddev_ident_s68,2060
} *mddev_ident_t;mddev_ident_t83,2389
typedef struct mddev_dev_s mddev_dev_s86,2456
} *mddev_dev_t;mddev_dev_t92,2644
typedef struct mapping mapping94,2661
} mapping_t;mapping_t97,2709
#define Sendmail 100,2740
extern mapping_t r5layout[105,2884
extern mapping_t r5layout[], pers[105,2884

mdctl.spec,235
Summary: mdctl is used for controlling Linux md devices 1,0
option of using a configuration file,18,630
raidtools uses a configuration file to describe how to create a RAID array,21,718
Further,23,871
stopping a raid array,24,941

raid5extend.c,39
int phys2log(2,1
raid5_extend(46,902

util.c,600
int parse_uuid(40,1359
int md_get_version(82,2122
int get_linux_version(101,2481
int enough(113,2678
int same_uuid(129,2928
void uuid_from_super(139,3057
int compare_super(153,3334
int load_super(187,4297
int store_super(227,4955
int check_ext2(253,5326
int check_reiser(284,6089
int check_raid(308,6645
int ask(324,7008
char *map_num(344,7373
int map_name(354,7508
struct devmap devmap369,7837
} *devlist 373,7916
int devlist_ready 374,7935
#define  __USE_XOPEN_EXTENDED376,7959
int add_dev(380,8008
char *map_dev(396,8375
int calc_sb_csum(412,8650
char *human_size(428,9046
